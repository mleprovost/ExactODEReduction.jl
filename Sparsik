
import Base64.+



#=
    _Sparsik:

    scale, inner, ∑, reduce,
    is_zero, first_nonzero
=#

struct _Sparsik
    _dim::Integer
    _nonzero::Any
    _data::Any

end



function print_vector(v)
    i = 1
    j = 1
    print("(")
    while i <= v._dim
        if j <= length(v._nonzero) && v._nonzero[j] == i
            print(v._data[i], ", ")
            j += 1
        else
            print(0, ", ")
        end
        i += 1
    end
    print(")\n")
end


function is_zero(v)
    return length(v._nonzero) == 0
end

function first_nonzero(v)
    return v._nonzero[1]
end

function scale_(v, c)
    for idx ∈ v._nonzero
        v._data[idx] *= c
    end
    return v
end



function ∑(v1, v2)

    new_indices = []
    new_data = Dict{Integer, Integer}()

    i, j = 1, 1

    while i <= length(v1._nonzero) || j <= length(v2._nonzero)
        new_idx, new_val = 1, 0
        if i <= length(v1._nonzero) && j <= length(v2._nonzero)
            if v1._nonzero[i] == v2._nonzero[j]
                new_val = v1._data[v1._nonzero[i]] + v2._data[v2._nonzero[j]]
                new_idx = v1._nonzero[i]
                i += 1
                j += 1
            elseif v1._nonzero[i] < v2._nonzero[j]
                new_val = v1._data[v1._nonzero[i]]
                new_idx = v1._nonzero[i]
                i += 1
            else
                new_val = v2._data[v2._nonzero[j]]
                new_idx = v2._nonzero[j]
                j += 1
            end
        elseif i <= length(v1._nonzero)
            new_val = v1._data[v1._nonzero[i]]
            new_idx = v1._nonzero[i]
            i += 1
        else
            new_val = v2._data[v2._nonzero[j]]
            new_idx = v2._nonzero[j]
            j += 1
        end

        if new_val != 0
            append!(new_indices, new_idx)
            new_data[new_idx] = new_val
        end

    end

    return _Sparsik(v1._dim, new_indices, new_data)

end


# returns v1 + v2 * c
function reduce_(v1, v2, c)
    return ∑(v1, scale_(v2, c))
end


function inner_(v1, v2)
    i, j = 1, 1
    ans = 0
    while i <= length(v1._nonzero) && j <= length(v2._nonzero)
        if v1._nonzero[i] == v2._nonzero[j]
            ans += v1._data[v1._nonzero[i]] * v2._data[v2._nonzero[j]]
            i += 1
            j += 1
        elseif v1._nonzero[i] < v2._nonzero[j]
            i += 1
        else
            j += 1
        end
    end
    return ans
end


function get_(v, i)
    return get(v._data, i, 0)
end


+(v::_Sparsik, u::_Sparsik) = ∑(v, u)


v1 = _Sparsik(7, [1, 3, 5, 7], Dict{Int64, Int64}(1 => 10, 3 => -2, 5 => 8, 7 => 4))
v2 = _Sparsik(7, [2, 3, 5, 6],  Dict{Int64, Int64}(2 => 2, 3 => 1, 5 => -8, 6 => 11))

print_vector(v1 + v2)


print_vector(v1)
print_vector(v2)

s = reduce_(v1, v2, 2)
print_vector(s)
print("vector of $(s._dim) with $(length(s._nonzero)) nonzero")

abcd = Dict{Int64, Int64}(1 => 10, 3 => -2, 5 => 8, 7 => 4)

println(get_(s, 1))
