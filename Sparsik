
import Base64.+, Base64.*, Base64.==



#=
    Sparsik:

    scale, inner, ∑, reduce,
    is_zero, first_nonzero
=#

struct Sparsik
    _dim::Integer
    _nonzero::Any
    _data::Any

end



function print_vector(v::Sparsik)
    i = 1
    j = 1
    print("(")
    while i <= v._dim
        if j <= length(v._nonzero) && v._nonzero[j] == i
            print(v._data[i], ", ")
            j += 1
        else
            print(0, ", ")
        end
        i += 1
    end
    print(")\n")
end


function is_zero(v::Sparsik)::Bool
    return length(v._nonzero) == 0
end

function first_nonzero(v::Sparsik)::Integer
    return v._nonzero[1]
end

function scale_(v::Sparsik, c::Integer)::Sparsik
    for idx ∈ v._nonzero
        v._data[idx] *= c
    end
    return v
end



function ∑(v1::Sparsik, v2::Sparsik)::Sparsik

    new_indices = []
    new_data = Dict()

    i, j = 1, 1

    while i <= length(v1._nonzero) || j <= length(v2._nonzero)
        new_idx, new_val = 1, 0
        if i <= length(v1._nonzero) && j <= length(v2._nonzero)
            if v1._nonzero[i] == v2._nonzero[j]
                new_val = v1._data[v1._nonzero[i]] + v2._data[v2._nonzero[j]]
                new_idx = v1._nonzero[i]
                i += 1
                j += 1
            elseif v1._nonzero[i] < v2._nonzero[j]
                new_val = v1._data[v1._nonzero[i]]
                new_idx = v1._nonzero[i]
                i += 1
            else
                new_val = v2._data[v2._nonzero[j]]
                new_idx = v2._nonzero[j]
                j += 1
            end
        elseif i <= length(v1._nonzero)
            new_val = v1._data[v1._nonzero[i]]
            new_idx = v1._nonzero[i]
            i += 1
        else
            new_val = v2._data[v2._nonzero[j]]
            new_idx = v2._nonzero[j]
            j += 1
        end

        if new_val != 0
            append!(new_indices, new_idx)
            new_data[new_idx] = new_val
        end

    end

    return Sparsik(v1._dim, new_indices, new_data)

end


# returns v1 + v2 * c
function reduce_(v::Sparsik, u::Sparsik, c::Integer)::Sparsik
    return ∑(v, scale_(u, c))
end


function inner_(v::Sparsik, u::Sparsik)::Integer
    i, j = 1, 1
    ans = 0
    while i <= length(v._nonzero) && j <= length(u._nonzero)
        if v._nonzero[i] == u._nonzero[j]
            ans += v._data[v._nonzero[i]] * u._data[u._nonzero[j]]
            i += 1
            j += 1
        elseif v._nonzero[i] < u._nonzero[j]
            i += 1
        else
            j += 1
        end
    end
    return ans
end


function get_(v::Sparsik, i::Integer)::Integer
    return get(v._data, i, 0)
end


+(v::Sparsik, u::Sparsik) = ∑(v, u)
*(v::Sparsik, c::Integer) = scale_(v, c)
==(v::Sparsik, u::Sparsik) = (v._dim == u._dim;
                                v._data == u._data;
                                v._nonzero == u._nonzero)

# ---------------------------------------


v1 = Sparsik(7, [1, 3, 5, 7], Dict(1 => 10, 3 => -2, 5 => 8, 7 => 4))
v2 = Sparsik(7, [2, 3, 5, 6],  Dict(2 => 2, 3 => 1, 5 => -8, 6 => 11))



@assert (v1 + v2) == Sparsik(7, [1, 2, 3, 6, 7], Dict(1=>10, 2=>2, 3=>-1, 6=>11, 7=>4))

@assert (v1 * 2) == Sparsik(7, [1, 3, 5, 7], Dict(1=>20, 3=>-4, 5=>16, 7=>8))

@assert is_zero(Sparsik(3, [], Dict()))

@assert first_nonzero(v2) == 2

@assert inner_(v1, v2) == -132
